
# Auto Generated README File
### Algorithms and Data Structures Problems:
1. *Arrays2DSearch.java* : Find a number in a sorted 2D array. Given a 2d array (NxM) where all the numbers (integers) in the array are in increasing order from left to right and top to bottom. You are also given a target number, to be searched inside the array. What is the best way to search and determine if a number is in the array.
2. *ArraysAlternatingPositiveNegative.java* : Given an array containing both positive and negative integers, return an array of alternating positive integers and negative integers such that each set of integers are in the same order as in the input array (stable). input {2,3,-4,-9,-1,-7,1,-5,-6} output {2,-4,3,-9,1,-1,-7,-5,-6} Implement it without using any additional space.
3. *ArraysAreaUnderHistogram.java* : Find the largest rectangular area possible in a given histogram where the largest rectangle can be made of a number of contiguous bars. For simplicity, assume that all bars have same width and the width is 1 unit. For example, consider the following histogram of 7 bars of heights {6,2,5,4,5,2,6}. The largest possible rectangle possible is 12. Max Area = 3 x 4 = 12
4. *ArraysHammingWeight.java* : Given a large array of 4-byte integers, write a method to find how many total bits are turned on (i.e. 1s are set) inside such an array [Such a digital sum of binary representation of a number, is also called its Hamming Weight]. e.g. 1. If input array has two numbers: 31 and 51, the answer is 9 because 31 has 5 bits turned on (out of 32) and 51 has 4. 2.If input is 2147483647 and 3, the answer is 31 + 2 = 33 Looking for a fast solution, even with extra memory.
5. *ArraysMergeOverlapingIntervals.java* : Given a set of time intervals in any order, merge all overlapping intervals into one and output the result which should have only mutually exclusive intervals. Examples: {{1,3},{2,4},{5,7},{6,8}} Intervals are {1,3} and {2,4} overlap with each other, so they shold be merged and become {1,4}. Similarly, {5,7} and {6,8} should be merged and become {5,8}
6. *ArraysMinimumRotatedArrays.java* : 
7. *ArraysNeuronyms.java* : L10n is a neuronym of the word "Localization" 10 stands for the number of letters between the first 'L' and the last 'n' in the word. Generate all such possible Numeronyms for any given string (character array). "Nailed": "n4d" "na3d", "n3ed" "n2led", "na2ed", "nai2d" e.g. for the word "batch" "b3h" "ba2h", "b2ch" Print strings in progressive order of longer strings. Stop when there are 2s.
8. *ArraysProduct.java* : Given an array of numbers, return an array of numbers products, where products[i] is the product of all nums[j], j != i Input : [1, 2, 3, 4, 5] Output: [(2*3*4*5),(1*3*4*5),(1*2*4*5),(1*2*3*5),(1*2*3*4)] This must be done in O(N) time and constant space without using division. Usage of products array is not considered extra space.
9. *ArraysRotatedSortedFindMinimum.java* : Given an array with sorted numbers. The array has been rotated an unknown number of times. We need to figure out the minimum number in such an array. What would be a fast method that uses only constant space? Examples: Input: {5,6,1,2,3,4} Output: 1
10. *ArraysSumZero.java* : Given a set of integers, find a contiguous subset whose sum is zero. There can be duplicate numbers in the input. Input: Integer array e.g. 5,1,2,3,7,-4 Output: A subset that sums to zero. e.g. 1,2,-3, or -3,7,-4 - If there are no such subsets, then print nothing. - If there are multiple such subsets, then print any one. - If a matching subset is a subset of a larger matching subset, then print either one. - If there is a number '0' in the array, then it counts as a valid answer subarray. What would be the complexity of the solution, if we were to print all subsets that sum to zero (instead of just one)?
11. *ByteArray.java* : 
12. *dailyPractice621.java* : LRU Cache
13. *dailyPractice919.java* : 
14. *DoublePower.java* : Double Power: Implement a power function to raise a double to an int power, including negative powers using recursion. e.g. pow(double d, int p) should give 'd' raised to power 'p'
15. *DPBalancedPartition.java* : 
16. *DPCountWaysToReachNthStairs.java* : There are n stairs, a person standing at the bottom wants to reach the top. The person can climb either 1 stair or 2 stairs at a time. Count the number of ways, the person can reach the top. Example: ------- Input: n = 1 Output: 1 There is only one way to climb 1 stair. Input: n = 2 Output: 2 There are two ways: (1,1) and (2) Input: n = 4 Output: 5 (1, 1, 1, 1), (1, 1, 2), (2, 1, 1), (1, 2, 1), (2, 2) Solve it for different steps that can be taken as well.
17. *DPLevenshteinEditDistance.java* : Given two words word1 and word2, find the minimun number of steps required to convert word1 to word2. (each operation is counted as 1 step.) You have the following 3 operations permitted on a word: a) Insert a character b) Delete a character c) Replace a character e.g. Minimum edit distance between words 'kitten' and 'sitting' is 3. - kitten -> sitten (substitution of "s" for "k") - sitten -> sittin (substitution of "i" for "e") - sittin -> sitting (insertion of "g" and end) (Assume all inputs and substitutions in lower case)
18. *DPLevenshteinEditDistance1.java* : Given two words, find the minimum number of steps to convert word1 to word2 using the Levenshtein or Edit distance algorithm.
19. *DPLongestCommonSubsequence.java* : Given two sequences, find the longest subsequence present in both of them. (Not just the length, but the actual string) The longest common subsequence (LCS) problem is the problem of finding the longest subsequence common to all the sequences in a set of sequences (often just two sequences). It differs from problems of finding common substrings: unlike substrings, subsequences are not required to occupy consecutive positions within the original sequences. The longest common subsequence problem is a classic computer science problem, the basis of data comparison programs such as the diff utility, and has applications in bioinformatics. It is also widely used by revision control systems such as Git for reconciling multiple changes made to a revision-controlled collection of files (Source Wikipedia) For example "abc", "abg", "bdf", "aeg", "acefg", ..etc are subsequences of "abcdefg". So, a string of length 'n' has 2^n different possible subsequences. LCS for input sequences "ABCDGH" and "AEDFHR" is "ADH" of length 3. LCS for input sequences "AGGTAB" and "GXTXAYB" is "GTAB" of length 4.
20. *DPMakingChange.java* : You are given n types of coin denominators of values v(1) < v(2) < ... < v(n) (all integers). Give an algorithm which makes change for an amount of money C with as few coins as possible. Assume there are multiple coins of every denomination. Assume v(1) = 1, (i.e. there is always a combination that leads to C). There may be multiple ways of reaching C. We want a DP based solution that leads to the method using least number of coins. Input: C and Denominations Array Output: Combination using minimum number of coins (repeat coins ok) that leads to C. Print any one Extra: Print all combinations. Hint: You'll need to do recursion on the DP table. e.g. Input: Denominations: 1,2,3 C:4 Output on two lines: 1,3 2,2
21. *DPRobbery.java* : There are n houses build in a line, each of which contains some value in it. A thief is going to steal the maximal value in these houses, but he cannot steal in two adjacent houses because the owner of a stolen house will tell his two neighbors on the left and right side. What is the maximal stolen value? For example, if there are four houses with values {6,1,2,7}, the maximal stolen value is 13 when the first and fourth houses are stolen.
22. *Graph.java* : 
23. *GraphAlienLanguageTopologicalSort.java* : Given a sorted dictionary of alen
24. *GraphKnightsTourOnChessBoard.java* : Assume you are given a normal chessboard and a knight that moves like a normal chess. You are then given two inputs: starting location and ending location in the form of x, y coordinates. The goal is to calculate the shortest number of moves that the knight can take to get to the target location. Input: (All the coordinates start with 0 and end with (rows-1) or (cols-1) For a 8xboard, the first cell will be (0,0) and the corresponding opposite corner cell will be (7,7)
25. *GraphsBloomFilter.java* : Code a simple Bloom Filter. 1. Read words of an English dictionary from a file. A large number (>100K) is required. Create one, or use one on your system (e.g. /usr/share/dict/words) 2. Add the words to a bloom filter (not a hash table, but a bloom filter) 3. Look up random words from the bloom filter 4. Do a comparison with linear-time searching the dictionary. You can also compare with Hash-table, but depending on how fast our machine is and how large your data-set, you may or may not see much speed up.
26. *GraphsDetectCycle.java* : Detect Cycle in a directed graph using colors. WHITE: Vertex not processed. GRAY: Vertex being processed. BLACK: Vertex and all descendants are processed.
27. *GraphsDetectingCycleInGraph.java* : Given a directed graph, check whether there is a cycle in it. There can be multiple cycles. No need to print. Just return true/ false if there is a cycle.
28. *GraphsKnightsTourOnAChessBoard.java* : Assume you are given a normal chessboard and a knight that moves like a normal chess. You are given two inputs: starting location and ending location in the form of x,y Coordinates. The goal is to calculate and print the shortest path that the knight can take to the target location.
29. *GraphsKnightsTourOnChessBoard.java* : Assume you are given a normal chessboard and knight that moves like a normal chess. You are given two inputs: starting location and ending location in the form of x, y coordinates. The goal is to calculate the shortest number of moves that the knight can take to get to the target location.
30. *GraphsRainfallChallenge.java* : 
31. *GraphsSkipList.java* : Simple, dynamic, randomized data structure O(log n) in expectation with high probability
32. *GraphsSnakesAndLaddersMatrix.java* : Given a snake and ladder rectangular MXN board-game, find the minimum number of dice throws required to reach the final cell from the 1st cell. Rules are as usual: If after a dice-throw, the player reaches a cell where the ladder starts, the player has to climb up that ladder and if the player reaches a cell that that has the mouth of the snake, s/he has to go down to the tail of the snake. For example, in the board below, it will take a minimum of 4 throws to reach from 1 to 36.
33. *GraphsTopologicalSort.java* : Given a sorted dictionary of an alien language, find order of characters. Example 1: Input: words[] = {"baa","abcd", "abca", "cab", "cad"} Output: Order of characters is 'b', 'd', 'a', 'c' Example 2: Input: words[] = {"caa", "aaa", "aab"} Output: Order of characters is 'c', 'a', 'b' Words are sorted and in the given language, "baa" comes before "abcd", therefore 'b' is before 'a' in output.
34. *GraphsTrie.java* : Build a Trie Data Structure.
35. *hello.java* : 
36. *LinkedListAlternativeNodeSplit.java* : Given a linked list, split it into two such that every other node goes into the new list. For lists with odd number of nodes, first one should be longer. For example: an input list: {a, b, c, d, e, f, g} results in {a, c, e, g} and {b, d, f}
37. *LinkedListCloneSpecialList.java* : You are given a Double Linked List with one pointer of each node pointing to the next node just like a single linked list. The second pointer however can point to any node in the list and not just the previous node. Write a program in O(n) time to duplicate this list / create a copy of this list. Let us call the second pointer as arbit pointer as it can point to any arbitrary node in the linked list. Use constant extra memory. |---------!|--------! 1 -> 2 -> 3 -> 4 -> 5 !----|!-------------| !-----|
38. *LinkedListFindMiddleElement.java* : Find the middle element of a singly linked list. Constraint: Do it in one pass over the list. If it is even number of elements, then output the 2nd of the middle two elements. Examples 1->2->3->null, answer=2 1->11->45->12->67->89->91->null, answer 12 1->11->45->12->67->89->null, answer 12 null, answer null
39. *LinkedListImplementMinStack.java* : Implement a Min Stack Your goal for this problem is to implement an additional method: "getMinimum()" for a stack. The method, as the name suggests, returns the minimum element in the entire stack. It shouldn't pop that element; it should only peek i.e. return the value. You may implement methods of the stack if there is time but focus on getMinimum(). getMinimum() should return in constant time. Example: 1) If the stack has 1,2,3,4,5 in that order from bottom to top, then the call to getMinimum() should return 1. 2) If the stack has 1,5,3,0 in that order from bottom to top, then the call to getMinimum() should return 0. 3) if the stack is empty, it should return NULL.
40. *LinkedListLongestSubstringMatchingParenthesis.java* : Find the length of the longest substring (contiguous) that has matching opening and closing parentheses. We only need length, not the substring itself. You may assume valid input for the purpose of this exercise i.e. Input string can only have parentheses and nothing else. e.g. 1. Input: "((((())(((()", Output: 4 2. Input: "((((", Output: 0 3. Input: "()()()", Output: 6 4. Input: "", Output: 0
41. *LinkedListLRUCache.java* : 
42. *LinkedListLRUCacheDesign.java* : Design an LRU cache add and get methods function in O(1) with a Linked List
43. *LinkedListMatchingParenthesis.java* : Write a function that checks if the given input string has matching opening and closing parenthesis. Valid parentheses are: '(',')','{','}','[',']'
44. *LinkedListMergeSort.java* : 
45. *LinkedListMergeSortLinkedList.java* : Mergesort a linked list
46. *LinkedListReverseInGroups.java* : Given a linked list, write a function to reverse every k nodes (where k is an input to the function). Example: Inputs: 1->2->3->4->5->6->7->8->NULL and K=3 Output: 3->2->1->6->5->4->8->7->NULL. Inputs: 1->2->3->4->5->6->7->8->NULL and K=5 Output: 5->4->3->2->1->8->7->6->NULL
47. *LinkedListsDuplicates.java* : Complete the optimal (Linked List) function so that it checks a Linked List for redundant nodes, removes them, and returns the modified list without altering the order of non-redundant nodes. Note: A redundant node is a node whose data matches the data of a previous node in the list (e.g.: given some node ni containing data di, if di == dj and i<j, node nj is redundant) Constraint: Each Linked List input has 10,000 nodes. 0<= di <= 1000 Input Format: A Linked List passed as an argument to the optimal (Linked List) function. Output Format: The optimal (Linked List) function should return the updated (non-redundant) Linked List.
48. *LinkedListSlidingMaximumWindow.java* : Long array is given and there is a sliding window size w which is moving from the left of the array to the right. You can only see the numbers w in the window. Print the maximum value for this array at each of these windows.
49. *LinkedListSlidingWindowMaximum.java* : A long array A[] is given to you. There is a sliding window of size w which is moving from the very left of the array to the array to the very right. You can only see the w numbers in the window. Each time the sliding window moves rightwards by one position. Following is an example: The array is [1 3 -1 -3 5 4 6 7], and w is 3. Window position Max --------------- --- [1 3 -1] -3 5 4 6 7 3 1 [3 -1 -3] 5 4 6 7 3 1 3 [-1 -3 5] 4 6 7 5 1 3 -1 [-3 5 4] 6 7 5 1 3 -1 -3 [5 4 6] 7 6 1 3 -1 -3 5 [4 6 7] 7 Input: A long array A[], and a window width w Output: An array B[], B[i] is the maximum value of from A[i] to A[i+w-1] Requirement: Find a good optimal way to get B[i]
50. *LinkedListSpecialClone.java* : 
51. *LinkedListSuperStack.java* : Super Stack: Implement a simple stack that accepts the following commands and performs the operations associated with them: - push k: push integer k onto the top of the stack - pop: pop the top element from the stack. It is guaranteed that this will not be called on an empty stack. - inc e k: Add k to each of the bottom e elements of the stack. If the stack is empty, print EMPTY instead. Input Format: Locked stub code. The first line contains an integer n indicating the number of operations to perform. Output: After performing each operation, print value of stack's top element on a new line. If the stack is empty, print EMPTY instead.
52. *LinkedListSwapKthNodes.java* : 
53. *LinkedListZip.java* : Zip a linked list from two ends
54. *LinkedListZip2.java* : 
55. *makingChange.java* : 
56. *MergeKSortedArrays.java* : 
57. *MinimumWindowSubstring.java* : Given a string S and a string T, find the minimum window in S which will contain all the characters in T. e.g. S = "AYZABOBECODXBANC" T = "ABC" Minimum window is "BANC", which contains all letters - A B and C - If no such window exists, then return an empty string - If there are multiple minimum windows of the same length, then return any one - Characters might be repeated
58. *Practice913.java* : 
59. *RecAllStar.java* : Given a string, compute recursively a new string where all the adjacent chars are now separated by a "*". allStar("hello") → "h*e*l*l*o" allStar("abc") → "a*b*c" allStar("ab") → "a*b"
60. *RecArray11.java* : 
61. *RecArray220.java* : Given an array of ints, compute recursively if the array contains somewhere a value followed in the array by that value times 10. We'll use the convention of considering only the part of the array that begins at the given index. In this way, a recursive call can pass index+1 to move down the array. The initial call will pass in index as 0. array220([1, 2, 20], 0) → true array220([3, 30], 0) → true array220([3], 0) → false
62. *RecArray6.java* : 
63. *RecBunnyEars.java* : Bunnies standing in line, numbered 1, 2, 3 ... Even bunnies have 2 ears and odd bunnies have 3 Count the total number of ears for the bunnies.
64. *RecChangePi.java* : Given a string, compute recursively (no loops) a new string where all appearances of "pi" have been replaced by "3.14". changePi("xpix") → "x3.14x" changePi("pipi") → "3.143.14" changePi("pip") → "3.14p"
65. *RecChangeXY.java* : Given a string, compute recursively (no loops) a new string where all the lowercase 'x' chars have been changed to 'y' chars. changeXY("codex") → "codey" changeXY("xxhixx") → "yyhiyy" changeXY("xhixhix") → "yhiyhiy"
66. *RecCount11.java* : Given a string, compute recursively (no loops) the number of "11" substrings in the string. The "11" substrings should not overlap. count11("11abc11") → 2 count11("abc11x11x11") → 3 count11("111") → 1
67. *RecCount7.java* : Given a non-negative int n, return the count of the occurrences of 7 as a digit, so for example 717 yields 2. (no loops). Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while divide (/) by 10 removes the rightmost digit (126 / 10 is 12).
68. *RecCount8.java* : Count8 problem Given a non-negative int n, compute recursively (no loops) the count of the occurrences of 8 as a digit, except that an 8 with another 8 immediately to its left counts double, so 8818 yields 4. Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while divide (/) by 10 removes the rightmost digit (126 / 10 is 12).
69. *RecCountAbc.java* : Count recursively the total number of "abc" and "aba" substrings that appear in the given string. countAbc("abc") → 1 countAbc("abcxxabc") → 2 countAbc("abaxxaba") → 2
70. *RecCountHi.java* : Given a string, compute recursively (no loops) the number of times lowercase "hi" appears in the string. countHi("xxhixx") → 1 countHi("xhixhix") → 2 countHi("hi") → 1
71. *RecCountHi2.java* : Given a string, compute recursively the number of times lowercase "hi" appears in the string, however do not count "hi" that have an 'x' immedately before them. countHi2("ahixhi") → 1 countHi2("ahibhi") → 2 countHi2("xhixhi") → 0
72. *RecCountPairs.java* : We'll say that a "pair" in a string is two instances of a char separated by a char. So "AxA" the A's make a pair. Pair's can overlap, so "AxAxA" contains 3 pairs -- 2 for A and 1 for x. Recursively compute the number of pairs in the given string. countPairs("axa") → 1 countPairs("axax") → 2 countPairs("axbx") → 1
73. *RecCountX.java* : Given a string, compute recursively (no loops) the number of lowercase 'x' chars in the string. countX("xxhixx") → 4 countX("xhixhix") → 3 countX("hi") → 0
74. *RecDPFibonacci.java* : 
75. *RecEndX.java* : 
76. *RecGroupNoAdj.java* : Given an array of ints, is it possible to choose a group of some of the ints, such that the group sums to the given target with this additional constraint: If a value in the array is chosen to be in the group, the value immediately following it in the array must not be chosen. (No loops needed.) groupNoAdj(0, [2, 5, 10, 4], 12) → true groupNoAdj(0, [2, 5, 10, 4], 14) → false groupNoAdj(0, [2, 5, 10, 4], 7) → false
77. *RecGroupSum.java* : Given an array of ints, is it possible to choose a group of some of the ints, such that the group sums to the given target? This is a classic backtracking recursion problem. Once you understand the recursive backtracking strategy in this problem, you can use the same pattern for many problems to search a space of choices. Rather than looking at the whole array, our convention is to consider the part of the array starting at index start and continuing to the end of the array. The caller can specify the whole array simply by passing start as 0. No loops are needed -- the recursive calls progress down the array. groupSum(0, [2, 4, 8], 10) → true groupSum(0, [2, 4, 8], 14) → true groupSum(0, [2, 4, 8], 9) → false
78. *RecGroupSum5.java* : Given an array of ints, is it possible to choose a group of some of the ints, such that the group sums to the given target with these additional constraints: all multiples of 5 in the array must be included in the group. If the value immediately following a multiple of 5 is 1, it must not be chosen. (No loops needed.) groupSum5(0, [2, 5, 10, 4], 19) → true groupSum5(0, [2, 5, 10, 4], 17) → true groupSum5(0, [2, 5, 10, 4], 12) → false
79. *RecGroupSum6.java* : Given an array of ints, is it possible to choose a group of some of the ints, beginning at the start index, such that the group sums to the given target? However, with the additional constraint that all 6's must be chosen. (No loops needed.) groupSum6(0, [5, 6, 2], 8) → true groupSum6(0, [5, 6, 2], 9) → false groupSum6(0, [5, 6, 2], 7) → false
80. *RecGroupSumClump.java* : Given an array of ints, is it possible to choose a group of some of the ints, such that the group sums to the given target, with this additional constraint: if there are numbers in the array that are adjacent and the identical value, they must either all be chosen, or none of them chosen. For example, with the array {1, 2, 2, 2, 5, 2}, either all three 2's in the middle must be chosen or not, all as a group. (one loop can be used to find the extent of the identical values). groupSumClump(0, [2, 4, 8], 10) → true groupSumClump(0, [1, 2, 4, 8, 1], 14) → true groupSumClump(0, [2, 4, 4, 8], 14) → false
81. *RecNestParen.java* : Given a string, return true if it is a nesting of zero or more pairs of parenthesis, like "(())" or "((()))". Suggestion: check the first and last chars, and then recur on what's inside them. nestParen("(())") → true nestParen("((()))") → true nestParen("(((x))") → false
82. *RecNoX.java* : Given a string, compute recursively a new string where all the 'x' chars have been removed. noX("xaxb") → "ab" noX("abc") → "abc" noX("xx") → ""
83. *RecPairStar.java* : Given a string, compute recursively a new string where identical chars that are adjacent in the original string are separated from each other by a "*". pairStar("hello") → "hel*lo" pairStar("xxyy") → "x*xy*y" pairStar("aaaa") → "a*a*a*a"
84. *RecParenBit.java* : Given a string that contains a single pair of parenthesis, compute recursively a new string made of only of the parenthesis and their contents, so "xyz(abc)123" yields "(abc)". parenBit("xyz(abc)123") → "(abc)" parenBit("x(hello)") → "(hello)" parenBit("(xy)1") → "(xy)"
85. *RecPowerN.java* : Given base and n that are both 1 or more, compute recursively (no loops) the value of base to the n power, so powerN(3, 2) is 9 (3 squared). powerN(3, 1) → 3 powerN(3, 2) → 9 powerN(3, 3) → 27
86. *RecSplit53.java* : Given an array of ints, is it possible to divide the ints into two groups, so that the sum of the two groups is the same, with these constraints: all the values that are multiple of 5 must be in one group, and all the values that are a multiple of 3 (and not a multiple of 5) must be in the other. (No loops needed.) split53([1, 1]) → true split53([1, 1, 1]) → false split53([2, 4, 2]) → true
87. *RecSplitArray.java* : Given an array of ints, is it possible to divide the ints into two groups, so that the sums of the two groups are the same. Every int must be in one group or the other. Write a recursive helper method that takes whatever arguments you like, and make the initial call to your recursive helper from splitArray(). (No loops needed.) splitArray([2, 2]) → true splitArray([2, 3]) → false splitArray([5, 2, 3]) → true
88. *RecSplitOdd10.java* : Given an array of ints, is it possible to divide the ints into two groups, so that the sum of one group is a multiple of 10, and the sum of the other group is odd. Every int must be in one group or the other. Write a recursive helper method that takes whatever arguments you like, and make the initial call to your recursive helper from splitOdd10(). (No loops needed.) splitOdd10([5, 5, 5]) → true splitOdd10([5, 5, 6]) → false splitOdd10([5, 5, 6, 1]) → true
89. *RecStrCopies.java* : Given a string and a non-empty substring sub, compute recursively if at least n copies of sub appear in the string somewhere, possibly with overlapping. N will be non-negative. strCopies("catcowcat", "cat", 2) → true strCopies("catcowcat", "cow", 2) → false strCopies("catcowcat", "cow", 1) → true
90. *RecStrCount.java* : Given a string and a non-empty substring sub, compute recursively the number of times that sub appears in the string, without the sub strings overlapping. strCount("catcowcat", "cat") → 2 strCount("catcowcat", "cow") → 1 strCount("catcowcat", "dog") → 0
91. *RecStrDist.java* : Given a string and a non-empty substring sub, compute recursively the largest substring which starts and ends with sub and return its length. strDist("catcowcat", "cat") → 9 strDist("catcowcat", "cow") → 3 strDist("cccatcowcatxx", "cat") → 9
92. *RecStringClean.java* : Given a string, return recursively a "cleaned" string where adjacent chars that are the same have been reduced to a single char. So "yyzzza" yields "yza". stringClean("yyzzza") → "yza" stringClean("abbbcdd") → "abcd" stringClean("Hello") → "Helo"
93. *RecSumDigits.java* : Given a non-negative int n, return the sum of its digits recursively (no loops). Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while divide (/) by 10 removes the rightmost digit (126 / 10 is 12). sumDigits(126) → 9 sumDigits(49) → 13 sumDigits(12) → 3
94. *RecTriangle.java* : A triangle made of blocks the following way: 		triangle(0) = 0 		triangle(1) = 1 		triangle(2) = 3 Find out the total number of blocks given the number of rows.
95. *RecursionCountTrees.java* : Write a function that will return the number of binary trees that can be constructed, with 'n' nodes. for, n=1 ==> 1 possible tree(just root) for, n=2 ==> 2 possible trees (1.root->right, 2.root->left) for, n=3 ==> 5 possible trees (1.root->right->right 2.root->right->left 3.root->left->left 4.root->left->right 5.root->left->right) If you keep solving them, it will form a series called Catalan numbers. There is a formula for it, however this is solved by reviewing the underlying recursion. Recursion is based on tree-topology. Contents are not important.
96. *RecursionDiameterBinaryTree.java* : Calculate the diameter of a binary tree. Diameter is the longest between two leaves of a tree. A path is the sum total of all distances (weights) attached to all edges between two nodes.
97. *RecursionDiameterNaryTree.java* : Calculate the diameter of a tree (not necessarily a binary tree). Diameter is the longest path between two leaves of a tree. A path is the sum total of all distances (weights) attached to all edges between the nodes. A tree is represented in a specific notation {0,1,{5,0}} - It starts with root (0), which has (1) child, which will follow in braces. - Inside the braces, it says that the distance (weight) of reaching that first child is 5 and that there are no more children after that (0) Some examples: - One node, no diameter ("{0,0}", 0) - One leaf ("{0,1,{5,0}}", 5) - Still one leaf ("{0,1,{5,1,{4,1,{7,0}}}}", 16) - Diameter of first son is the diameter of the tree ("{0,1,{5,2,{8,0},{7,0}}}", 15) - Diameter of last son is the diameter of the tree ("{0,3,{1,2,{5,0},{7,0}},{1,2,{6,0},{5,0}},{1,2,{10,0}, {9,0}}}", 19) - Diameter is between a leaf in the first son and leaf in the third son ("{0,3,{5,2,{8,0},{7,0}},{5,2,{9,0},{8,0}},{5,2,{10,0},{9,0}}}", 29)
98. *RecursionDoublePower.java* : Double Power: Implement a power function to raise a double to an int power, including negative powers using recursion. e.g. pow(double d, int p) should give 'd' raised to power 'p'
99. *RecursionExpEvaluator.java* : 
100. *RecursionExpressionEvaluator.java* : Given a string of integers as input, put between each pair of digits, one of {"", "*", "+"} such that the expression you get will evaluate to K (a number also given as input). Putting an empty string ("") between two numbers means, that the numbers are joined to form a new number (e.g. 1""2=12) Order of integers given as input needs to remain the same. Input: 1) String of positive integers 2) Target K (given constant) Output: all possible strings that evaluate to K Precedence of operators matters. In higher to lower precedence. 1. Join ("") 2. Multiplication (*) 3. Addition (+) If the input is "222" and the answer is "24", two possible options are: 1. 22+2 2. 2+22
101. *RecursionLongestIncreasingSubsequence.java* : Find size of longest increasing subsequence
102. *RecursionLongestIncSubsequence.java* : 
103. *RecursionNQueens.java* : Place N Queens on a chessboard so that no two queens are in line of attack of each other.
104. *RecursionPalindromeDecomposition.java* : Return all possible strings with Palindromic Decompositions Depth First Search
105. *RecursionPalindromeDecompositionDP.java* : 
106. *RecursionPalindromicDecomposition.java* : A Palindromic Decomposition of a string S, is a decomposition of the strings into substrings such that all those substrings are valid palindromes. A single character is considered a valid palindrome for this problem. Print out all possible palindromic decompositions of a given string. Example: Input: abracadabra Output: a|b|r|a|c|a|d|a|b|r|a| a|b|r|a|c|ada|b|r|a| a|b|r|aca|d|a|b|r|a|
107. *RecursionSubsetOfASet.java* : Print all subsets of a set. E.g. {x,y} => {{},{x},{y},{x,y}} Since we are working with sets {y,x} is not different from {x,y}. {x,x} is not a valid subset, unless the input also has two x's. {1,2,3} => {{},{1},{2},{3},{1,2},{1,3},{2,3},{1,2,3}} Input: Set, as an array. Output: Subsets in any order.
108. *RecursionTreeDiameter.java* : Calculate the diameter of a tree (not necessarily a binary tree). Diameter is the longest path between two leaves of a tree. A path is the sum total of all distances (weights) attached to all edges between the nodes. A tree is represented in a specific notation {0,1,{5,0}} - It starts with root (0), which has (1) child, which will follow in braces. - Inside the braces, it says that the distance (weight) of reaching that first child is 5 and that there are no more children after that (0) Some examples: - One node, no diameter ("{0,0}", 0) - One leaf ("{0,1,{5,0}}", 5) - Still one leaf ("{0,1,{5,1,{4,1,{7,0}}}}", 16) - Diameter of first son is the diameter of the tree ("{0,1,{5,2,{8,0},{7,0}}}", 15) - Diameter of last son is the diameter of the tree ("{0,3,{1,2,{5,0},{7,0}},{1,2,{6,0},{5,0}},{1,2,{10,0}, {9,0}}}", 19) - Diameter is between a leaf in the first son and leaf in the third son ("{0,3,{5,2,{8,0},{7,0}},{5,2,{9,0},{8,0}},{5,2,{10,0},{9,0}}}", 29)
109. *RecursionValidWords.java* : 
110. *RecursionWildcard.java* : Input 10? Output 101, 100 ie ? behaves like a wild-card. There are two possibilties for 10?, when that ? is replaced with either 0 or 1. Write a program that takes given strings as input and produces suggested output.
111. *RegexMatcher.java* : Implement a regular expression matcher, supporting the following characters: - a dot ('.') '.' Matches any single character. - a star ('*') '*' Matches zero or more of the preceding element.
112. *Sorting3Sum.java* : 3Sum: Find 3 numbers that add up to 0 in an array.
113. *Sorting3SumProblem.java* : Given an array of N integers, find all triplets that sum to 0 (zero) Triplets may or may not be consecutive numbers. The array can include duplicate elements. Array is not necessarily sorted. Print output as shown .i.e. as strings, one per line, comma separated elements. Order of elements inside the answer triplets does not matter. i.e. if your output elements are the same, but only in different order, then it's an acceptable solution. Do not print duplicate triplets. If no such triplets are found, then print nothing. Can't do better than n^2.
114. *SortingDuplicateInLoosePermutation.java* : Find a duplicated number in a loose permutation of numbers. A permutation is an array that is size N, also has positive numbers from 1 through N. A loose permutation is a permutation where some numbers are missing and some are duplicated, but the total number is still N. - We want to find any one duplicated number; not necessarily the first or the least. - It can occur anywhere in the input array, and we don't care how many times it is duplicated. - Input array may nor may not be sorted. - You can only use constant extra memory. - There is no limit/constraint on N i.e. it is a normal 4-byte integer e.g. Input: 1,7,4,3,2,7,4: This array has 7 numbers from 1 thru 7, with some missing (5 and 6) and some duplicated (4 and 7). Albeit unsorted, but sorting is irrelevant to a permutation. Output: 4 or 7 Input: 3, 1, 2: This has nothing missing Output: -1
115. *SortingFindIntegerNotAmongMillionOne.java* : 
116. *SortingFindNearestNeighbor.java* : Given a point P, and other N points in two dimensional space, find K points out of the N points which are nearest to P. Distance between two points is measured by standard euclidean method. (Hint: This problem can either be done with QuickSort partitioning, or can be done with Heaps. Which one would you use? Why? Why not try both in your IDE and see how much the runtime complexity works to be?
117. *SortingGroupTheNumbers.java* : Given an array of numbers, positive integers only, group them in-place into evens and odds. Input: Integer array, positive integers only, repeats possible. Output: The same integer array, with evens on left side and odds on right side. No need to preserve order within odds or evens. Grouping is a special case of sorting. It's less complex and can be done with easier methods not labeled as sorting but special case.
118. *SortingMergeKSortedArrays.java* : Given K sorted arrays of size N each, merge them and print the sorted output. Assume N is very large compared to K. N may not even be known. i.e. the arrays could be just sorted streams, e.g. timestamp streams. Input: K=3, N=4 arr[][] = {{1,3,5,7},{2,4,6,8},{0,9,10,11}} First parameter: How many arrays. Second parameter: Length of each array. Output: 0 1 2 3 4 5 6 7 8 9 10 11 Repeats are allowed. Negative numbers and zeros are allowed. Assume all arrays are sorted in the same order. *	Use a heap to merge the sorted arrays.
119. *SortingMergesort.java* : Convert standard merge-sort algorithm into code. Input: Integers in an array. Duplicates are possible. Output: Same integers in ascending order in a new array. Preserve input array. Goal: Review concept of partitioning, merging partitions, understanding that merge sort needs extra space, why worst case is better than Quicksort.
120. *SortingMergesort2.java* : 
121. *SortingMinHeap.java* : 
122. *SortingMinHeap2.java* : Using built-in function, Priority Queue to use a Min Heap
123. *SortingMinHeapTopK.java* : 
124. *SortingNearestNeighbor.java* : Sorting Nearest Neighbor Given a point P, and other N points in two dimensional space, find K points out of the N points which are nearest to P. *Distance between two points is measured by standard eucledian distance formula d(x,y) = sqrt((y2 - y1)^2 + (x2 - x1)^2)
125. *SortingNutsAndBolts.java* : A disorganized carpenter has a mixed pile of bolts and nuts and would like to find the corresponding pairs of bolts and nuts. Each nut matches exactly one bolt. (And vice versa). By trying to match a bolt and a nut the carpenter can see which one is bigger but she cannot compare two bolts or nuts directly. Write an algorithm to match each nut to bolt. Assumptions: Equal number of nuts and bolts. A given nut uniquely matches a bolt. There are not unmatched nuts or bolts. Input: N3, N2, N1, N4 B4, B2, B3, B1 Output: N1B1 N2B2 N3B3 N4B4
126. *SortingNutsAndBolts2.java* : 
127. *SortingQuicksort.java* : 
128. *SortingQuicksortNutsAndBolts.java* : 
129. *SortingSortAllCharactersInString.java* : Input: A string of characters, like a full English sentence, delimited by a new line or NULL. Duplicates are okay. Output: A string of characters, in sorted order of their ASCII values. You can overwrite the existing array. Solution Complexity: Aim for linear time and constant additional space. ASCII is limited to 256, that is bound to a range for input.
130. *SortingTopK.java* : Find K largest elements from a given stream of numbers. By definition, we don't know the size of the input stream. Hence, produce k largest elements seen so far, at any given time. - Input may or may not be sorted and could have duplicates. - Represent input stream as an array. Do not rely on its size. - Feel free to use built-in functions if you need a specific data-structure. - If your output is correct, but a test-case is failing because order of output elements is different, move on.
131. *StacksSuperStack.java* : 
132. *StringLongestSubstringwithAtMostTwoDistinctCharacters.java* : Given a string, find the length of the longest substring T that contains at most 2 distinct characters. For example, Given s = "eceba", T is "ece" which is length 3. If there is no such substrings, then print nothing If multiple substring exist, print any of them
133. *StringsInterleave.java* : 
134. *StringsJoinWordsToMakePalindrome.java* : Given a list of words, is there any pair of words that can be joined (in any order) to form a palindrome? Example 1: Consider a list {bat, tab, cat}. Then bat and tab can be joined together to form a palindrome. Example 2: {ab, deedba} can be joined to form a palindrome. Example 3: {ant, cat, dog} No words can be joined to form a palindrome Expected solution, given n = number of words and k is length of the longest word, O(N.K^2) solution for this problem is relatively straightforward to come by, using Maps or Tries. That may suffice for most interviews.
135. *StringsKMP.java* : 
136. *StringsLongestPalindromicSubstring.java* : Given some text, find the longest palindromic substring. Example: "cmadamd", longest palindromic substring: "cmadamd"
137. *StringsLongestRepeatedSubstring.java* : Given a string, find the longest repeated substring in it. Repeated is occurring more than once. It doesn't matter how many times it occurs beyond 2 times. Examples: -------- ABABABA => ABABA ATCGATCGA => ATCGA banana => ana Once a O(n^2) answer has been given, the interviewer would like to know if you know suffix trees. It doesn't have to be implemented.
138. *StringsNeuronyms.java* : Neuronym is a string that contains the count of number of letters between a set of letters. Generate all possible Neuronyms for a given string. Nailed: "n4d" "na3d", "n3ed" "n2led", "na2ed", "nai2d" Print progressively longer strings
139. *StringsPrintSinusoidal.java* : Problem is also called "SnakeString". Word separators should be printed with '~'.
140. *StringsSearchConcatenatedWords.java* : Search concatenated words Given two things: 1. Some text, say T 2. An array A of N Strings, all with the same length, say K Find all the starting points (indices) in T, which has a concatenation of N strings e.g. T = "dogthecatcatthedog" A = {"the", "cat"} N=2, K=3 Answer = {3,9} At Index 3, we have the phrase "thecat" and at index 9, we have "catthe". They are concatenations of two words in A. Print empty string if no combination exists.
141. *Tests.java* : 
142. *TreeBinarySearch.java* : 
143. *TreeCloneBinaryTree.java* : Give a binary tree (represented by its root node, like usual), clone it. Return the root of the cloned tree. Tips: cloning or copying tree is best done recursively. BFS could get complicated to handle implementation.
144. *TreeFlip.java* : Reverse a general binary tree. Flip it from right to left.
145. *TreeIsItBST.java* : 
146. *TreeIsItBST2.java* : Given a Binary Tree, check if it is a Binary Search Tree (BST). A valid BST doesn't have to complete or balanced. Duplicate elements are not allowed in a BST.
147. *TreeIterator.java* : Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. 1. Calling next() will return the next smallest number in the BST. 2. Calling hasNext() should return whether the next element exists. Both functions should run in average O(1) time and uses O(h) memory, where h is the height of the tree.
148. *TreeLargestBST.java* : Given a binary tree, find the largest Binary Search Tree (BST), where largest means BST with largest number of nodes in it. The largest BST must include all of its descendants.
149. *TreeLeastCommonAncestors.java* : Let T be a rooted tree. The lowest common ancestor between two nodes n1 and n2 is defined as the lowest node in T that has both n1 and n2 as descendants. The LCA of n1 and n2 in T is the shared ancestor of n1 and n2 that is located farthest from the root. Computation of lowest common ancestors may be useful, for instance, as part of a procedure for determining the distance between pairs of nodes in a tree: the distance from n1 to n2 can be computed as the distance from the root to n1, plus the distance from the root to n2, minus twice the distance from the root to their lowest common ancestor. Design and write an algorithm to find the LCA node, given two nodes in a Binary Tree. - The tree may or may not be a BST - Assume a Node structure that has NO parent pointer - Assume that the two nodes are distinct and exist in the tree - Find a solution that has a runtime complexity of O(N). N is # of nodes in the tree. Given the following tree: 45 / \ 25 65 / \ / \ 15 30 55 75 / \ / \ / \ 10 20 50 60 70 80 FindLCA(10,20) = 15 FindLCA(50,80) = 65 FindLCA(20,60) = 45 Desired solution: O(N) time.
150. *TreeMergeTwoBST.java* : Merge two BSTs in O(N1 + N2) time, where N1 and N2 are the number of nodes in the two trees respectively. The merged tree should contain all the elements of both trees and also be a balanced BST. Finally, print the new tree level by level. Example: Tree1: 2->1, 3 Tree2: 7->6, 8 Output: 6 2 7 1 3 8
151. *TreePostOrderTraversalNonRecursive.java* : Write a function to traverse a Binary Tree PostOrder without using recursion. Print contents of nodes as traversed.
152. *TreePostOrderTraversalNoRecursion.java* : Write a function to traverse a Binary tree PostOrder, without using recursion. Print nodes as traversing.
153. *TreesBSTtoCircularDoublyLinkedList.java* : Write a recursive function treeToList(Node root) that takes a BST and rearranges the internal pointers to make a circular doubly linked list out of the tree nodes. The "previous" pointers should be stored in the "Left" field and the "next" pointers should be stored in the "Right" field. The list should be arranged so that the nodes are in increasing order. Return the head pointer to the new list. The operation can be done in O(n) time.
154. *TreeSingleValue.java* : Given a binary tree, count number of unival subtrees (all nodes that have same value). Example: the following tree has 6 unival trees. Leafs are counted as one tree. 5 / \ 5 5 /\ \ 5 5 5
155. *TreesNQueens.java* : Place N queens on an NxN chessboard, such that no two queens are in liner of attack of each other. In chess, a queen can move as far as she pleases (i.e. horizontally, vertically or diagonally). Input: N Output: all possible arrangements of N queens on the board. Each arrangement can be represented by a matrix. Print the entire matrix, one per valid arrangement. For example, for N=4, there are two possible arrangements, that can be printed as: +-+-+-+-+ | | |*| | +-+-+-+-+ |*| | | | +-+-+-+-+ | | | |*| +-+-+-+-+ | |*| | | +-+-+-+-+ +-+-+-+-+ | |*| | | +-+-+-+-+ | | | |*| +-+-+-+-+ |*| | | | +-+-+-+-+ | | |*| | +-+-+-+-+ Solve the N Queen problem using recursion. To test, in your main method, call your function for every N from 1 through 10, and print the output.
156. *TreesPopulateSiblingsPointers.java* : Populate sibling pointers Given a full binary tree, populate the nextRight pointers in each node. Full binary tree = every node other than leaves has two children.
157. *TreesPrintAllPaths.java* : Given a binary tree, print out all of its root-to-leaf paths one per line.
158. *TreesPrintAllPaths2.java* : 
159. *TreesRebuildTree.java* : Given the in-order and pre-order traversal results of a binary tree as an array, write a function to rebuild the tree. The function should return the pointer to the root node of the tree. Then, take that pointer and print the tree level by level (level order) Note: One needs to be given in-order traversal (with either pre or post or level), as input, in order to re-construct a binary tree. Without in-order traversal given, it's not possible to re-construct a binary tree. An exception is that if we know something more about the tree such as if it is full and complete
